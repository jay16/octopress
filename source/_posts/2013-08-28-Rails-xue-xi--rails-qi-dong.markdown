---
layout: post
title: Rails学习 - rails启动
date: 2013-08-28 14:45:47
comments: true
categories: code
---
## 查看rails执行项

使用`which`查看rails系统命令文件所在位置:

    [root@localhost jay]# which rails
    /usr/local/bin/rails

添加`puts`,查看程序调用走向。

    [root@localhost jay]# vi /usr/local/bin/rails
    #!/usr/local/bin/ruby
    #
    # This file was generated by RubyGems.
    #
    # The application 'railties' is installed as part of a gem, and
    # this file is here to facilitate running it.
    
    require 'rubygems'
    
    version = ">= 0"
    
    puts "ARGV:#{ARGV.join(',')}"
    
    if ARGV.first
      str = ARGV.first
      puts "str:#{str}"
    
      str = str.dup.force_encoding("BINARY") if str.respond_to? :force_encoding
    
      if str =~ /\A_(.*)_\z/
        version = $1
        ARGV.shift
        puts "/\A_(.*)_\z/"
      end
    end
    
    puts "begin railties"
    
    gem 'railties', version
    #load Gem.bin_path('railties', 'rails', version)
    #查看加载项走向
    puts Gem.bin_path('railties', 'rails', version)

    [root@localhost jay]# rails dd
    ARGV:dd
    str:dd
    begin railties
    /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/bin/rails
    [root@localhost jay]# 

## rails

    # /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/bin/rails
    #!/usr/bin/env ruby
    
    if File.exists?(File.join(File.expand_path('../../..', __FILE__), '.git'))
      railties_path = File.expand_path('../../lib', __FILE__)
      $:.unshift(railties_path)
    end
    require "rails/cli

查看`railties_path`通过`expand_path`扩展,路径改变成什么了?

    [root@localhost jay]# cat expand_path.rb 
    dd = "/usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/bin/rails"
    railties_path = File.expand_path('../../lib', File.join(dd,"."))
    puts railties_path
    
    [root@localhost jay]# ruby expand_path.rb 
    /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/lib
    # 即railties_path 即为上述路径

`$:`存放ruby全局path路径。`$:.unshift(railties_path)`即在该数组头部插入一笔。

    [root@localhost jay]# vi dd.rb 
     puts $:.class
     puts $:.to_s
    [root@localhost jay]# ruby dd.rb 
    Array
    ["/usr/local/lib/ruby/site_ruby/1.9.1", 
    "/usr/local/lib/ruby/site_ruby/1.9.1/i686-linux", 
    "/usr/local/lib/ruby/site_ruby",
    "/usr/local/lib/ruby/vendor_ruby/1.9.1", 
    "/usr/local/lib/ruby/vendor_ruby/1.9.1/i686-linux",
    "/usr/local/lib/ruby/vendor_ruby", 
    "/usr/local/lib/ruby/1.9.1", 
    "/usr/local/lib/ruby/1.9.1/i686-linux"]

`require "rails/cli`会在`$:`路径数组中查找那个路径下含有文件`rails/cli`


## cli

    [root@localhost jay]# vi /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/lib/rails/cli.rb
    
    require 'rbconfig'
    require 'rails/script_rails_loader'
    
    # If we are inside a Rails application this method performs an exec and thus
    # the rest of this script is not run.
    Rails::ScriptRailsLoader.exec_script_rails!
    
    require 'rails/ruby_version_check'
    Signal.trap("INT") { puts; exit(1) }
    
    if ARGV.first == 'plugin'
      ARGV.shift
      require 'rails/commands/plugin_new'
    else
      require 'rails/commands/application'
    end

`rbconfig`是对`ruby标准库`的配置和补充，在ruby编译的时候起效，和rails关系不大。

`ARGV`为参数数组，平时我们常用的`rails`命令有`rails server`等，这时走向为`rails/commands/application`

## script_rails_loader.rb 

    [root@localhost jay]# vi /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/lib/rails/script_rails_loader.rb 
    
    require 'pathname'
    
    module Rails
      module ScriptRailsLoader
        RUBY = File.join(*RbConfig::CONFIG.values_at("bindir", "ruby_install_name")) + RbConfig::CONFIG["EXXT"]
        SCRIPT_RAILS = File.join('script', 'rails')
    
        def self.exec_script_rails!
          cwd = Dir.pwd
          return unless in_rails_application? || in_rails_application_subdirectory?
          exec RUBY, SCRIPT_RAILS, *ARGV if in_rails_application?
          Dir.chdir("..") do
            # Recurse in a chdir block: if the search fails we want to be sure
            # the application is generated in the original working directory.
            exec_script_rails! unless cwd == Dir.pwd
          end
        rescue SystemCallError
          # could not chdir, no problem just return
        end
    
        def self.in_rails_application?
          File.exists?(SCRIPT_RAILS)
        end
    
        def self.in_rails_application_subdirectory?(path = Pathname.new(Dir.pwd))
          File.exists?(File.join(path, SCRIPT_RAILS)) || !path.root? && in_rails_application_subdirectory?(path.parent)
        end
      end
    end

script_rails_loader.rb文件，里面定义了两个常量.

    RUBY = File.join(\*RbConfig::CONFIG.values_at("bindir", "ruby_install_name")) + RbConfig::CONFIG["EXXT"]
    SCRIPT_RAILS = File.join('script', 'rails')

`RUBY`是ruby的bin文件位置，指向可执行文件。

`SCRIPT_RAILS`就是指向`rails`**生成项目**`script目录`下的rails脚本。


`Rails::ScriptRailsLoader.exec_script_rails!`的执行代码如下

        def self.exec_script_rails!
          # 当前目录路径
          cwd = Dir.pwd
          
          # in_rails_application? 与 in_rails_application_subdirectory?下面会提到
          #如果当前路径即不是/script/rails也不是其子文件夹,就退出
          return unless in_rails_application? || in_rails_application_subdirectory?
          
          # exec 即执行bash命令
          #相当于ruby scripe/rails s 即我们常输入的rails s命令
          #前提是当前路径即是script/rails
          exec RUBY, SCRIPT_RAILS, *ARGV if in_rails_application?
          
          # 后退到父路径,相当于cd ..
          Dir.chdir("..") do
            # Recurse in a chdir block: if the search fails we want to be sure
            # the application is generated in the original working directory.
            #若找不到应用程序脚本,就会一直执行这个代码块
            exec_script_rails! unless cwd == Dir.pwd
          end
        rescue SystemCallError
          # could not chdir, no problem just return
        end

        #判断是否存在 [项目/script/rails] 文件
        def self.in_rails_application?
          File.exists?(SCRIPT_RAILS)
        end
    
        #判断是否在 [项目/script/rails] 的子文件夹内
        def self.in_rails_application_subdirectory?(path = Pathname.new(Dir.pwd))
          File.exists?(File.join(path, SCRIPT_RAILS)) || !path.root? && in_rails_application_subdirectory?(path.parent)
        end

## script#rails 

 `exec RUBY, SCRIPT_RAILS, *ARGV`其实是在执行	`SCRIPT_RAILS`
 
`SCRIPT_RAILS`就是指向`rails`**生成项目**`script目录`下的rails脚本。内容如下:


    [root@localhost jay]# vi rails/solife/script/rails 
    # solife为项目目录
    #!/usr/bin/env ruby
    # This command will automatically be run when you run "rails" with Rails 3 gems installed from the root of your application.
    
    APP_PATH = File.expand_path('../../config/application',  __FILE__)
    require File.expand_path('../../config/boot',  __FILE__)
    require 'rails/commands'
`APP_PATH`是rails项目的配置文件
 

### config#boot

boot文件是用来加载gemfile

    require 'rubygems'
    
    # Set up gems listed in the Gemfile.
    ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)
    
    require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])

## command

    [root@localhost jay]# vi /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/lib/rails/commands.rb 
    
    require 'active_support/core_ext/object/inclusion'
    
    #若没有传入参数,把--help字符串push到参数数组ARGV
    ARGV << '--help' if ARGV.empty?
    
    #命令与缩写对应表
    aliases = {
      "g"  => "generate",
      "d"  => "destroy",
      "c"  => "console",
      "s"  => "server",
      "db" => "dbconsole",
      "r"  => "runner"
    }
    
    #弹出第一个参数
    command = ARGV.shift
    #如果输入的是缩写命令 aliases[command]会返回完整命令
    #否则直接使用当前命令
    command = aliases[command] || command
    
    case command
    when 'generate', 'destroy', 'plugin'
      require 'rails/generators'
    
      if command == 'plugin' && ARGV.first == 'new'
        require "rails/commands/plugin_new"
      else
        require APP_PATH
        Rails.application.require_environment!
    
        Rails.application.load_generators
    
        require "rails/commands/#{command}"
      end
    
    when 'benchmarker', 'profiler'
      require APP_PATH
      Rails.application.require_environment!
      require "rails/commands/#{command}"
    
    when 'console'
      require 'rails/commands/console'
      require APP_PATH
      Rails.application.require_environment!
      Rails::Console.start(Rails.application)
    
    #最常用的启动服务命令
    when 'server'
      # Change to the application's path if there is no config.ru file in current dir.
      # This allows us to run script/rails server from other directories, but still get
      # the main config.ru and properly set the tmp directory.
      Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exists?(File.expand_path("config.ru"))
    
      #rails server代码
      require 'rails/commands/server'
      #创建rails服务
      Rails::Server.new.tap { |server|
        # We need to require application after the server sets environment,
        # otherwise the --environment option given to the server won't propagate.
        require APP_PATH
        Dir.chdir(Rails.application.root)
        server.start
      }
    
    when 'dbconsole'
      require 'rails/commands/dbconsole'
      require APP_PATH
      Rails::DBConsole.start(Rails.application)
    
    when 'application', 'runner'
      require "rails/commands/#{command}"
    
    when 'new'
      puts "Can't initialize a new Rails application within the directory of another, please change to a non-Rails directory first.\n"
      puts "Type 'rails' for help."
      exit(1)
    
    when '--version', '-v'
      ARGV.unshift '--version'
      require 'rails/commands/application'
    
    else
      puts "Error: Command not recognized" unless command.in?(['-h', '--help'])
      puts <<-EOT
    Usage: rails COMMAND [ARGS]
    
    The most common rails commands are:
     generate    Generate new code (short-cut alias: "g")
     console     Start the Rails console (short-cut alias: "c")
     server      Start the Rails server (short-cut alias: "s")
     dbconsole   Start a console for the database specified in config/database.yml
                 (short-cut alias: "db")
     new         Create a new Rails application. "rails new my_app" creates a
                 new application called MyApp in "./my_app"
    
    In addition to those, there are:
     application  Generate the Rails application code
     destroy      Undo code generated with "generate" (short-cut alias: "d")
     benchmarker  See how fast a piece of code runs
     profiler     Get profile information from a piece of code
     plugin       Install a plugin
     runner       Run a piece of code in the application environment (short-cut alias: "r")
    
    All commands can be run with -h (or --help) for more information.
      EOT
      exit(1)
    end

## server

    [root@localhost jay]# cat /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/lib/rails/commands/server.rb 
    require 'fileutils'
    require 'optparse'
    require 'action_dispatch'
    
    module Rails
      class Server < ::Rack::Server
        class Options
          def parse!(args)
            args, options = args.dup, {}
    
            opt_parser = OptionParser.new do |opts|
              opts.banner = "Usage: rails server [mongrel, thin, etc] [options]"
              opts.on("-p", "--port=port", Integer,
                      "Runs Rails on the specified port.", "Default: 3000") { |v| options[:Port] = v }
              opts.on("-b", "--binding=ip", String,
                      "Binds Rails to the specified ip.", "Default: 0.0.0.0") { |v| options[:Host] = v }
              opts.on("-c", "--config=file", String,
                      "Use custom rackup configuration file") { |v| options[:config] = v }
              opts.on("-d", "--daemon", "Make server run as a Daemon.") { options[:daemonize] = true }
              opts.on("-u", "--debugger", "Enable ruby-debugging for the server.") { options[:debugger] = true }
              opts.on("-e", "--environment=name", String,
                      "Specifies the environment to run this server under (test/development/production).",
                      "Default: development") { |v| options[:environment] = v }
              opts.on("-P","--pid=pid",String,
                      "Specifies the PID file.",
                      "Default: tmp/pids/server.pid") { |v| options[:pid] = v }
    
              opts.separator ""
    
              opts.on("-h", "--help", "Show this help message.") { puts opts; exit }
            end
    
            opt_parser.parse! args
    
            options[:server] = args.shift
            options
          end
        end
    
        def initialize(\*)
          super
          set_environment
        end
    
        def app
          @app ||= super.respond_to?(:to_app) ? super.to_app : super
        end
    
        def opt_parser
          Options.new
        end
    
        def set_environment
          ENV["RAILS_ENV"] ||= options[:environment]
        end
    
        #启动后最常见的输出项
        def start
          url = "#{options[:SSLEnable] ? 'https' : 'http'}://#{options[:Host]}:#{options[:Port]}"
          puts "=> Booting #{ActiveSupport::Inflector.demodulize(server)}"
          puts "=> Rails #{Rails.version} application starting in #{Rails.env} on #{url}"
          puts "=> Call with -d to detach" unless options[:daemonize]
          trap(:INT) { exit }
          puts "=> Ctrl-C to shutdown server" unless options[:daemonize]
    
          #Create required tmp directories if not found
          %w(cache pids sessions sockets).each do |dir_to_make|
            FileUtils.mkdir_p(Rails.root.join('tmp', dir_to_make))
          end
    
          super
        ensure
          # The '-h' option calls exit before @options is set.
          # If we call 'options' with it unset, we get double help banners.
          puts 'Exiting' unless @options && options[:daemonize]
        end
    
        def middleware
          middlewares = []
          middlewares << [Rails::Rack::LogTailer, log_path] unless options[:daemonize]
          middlewares << [Rails::Rack::Debugger]  if options[:debugger]
          middlewares << [::Rack::ContentLength]
          Hash.new(middlewares)
        end
    
        def log_path
          "log/#{options[:environment]}.log"
        end
    
        def default_options
          super.merge({
            :Port        => 3000,
            :environment => (ENV['RAILS_ENV'] || "development").dup,
            :daemonize   => false,
            :debugger    => false,
            :pid         => File.expand_path("tmp/pids/server.pid"),
            :config      => File.expand_path("config.ru")
          })
        end
      end
    end
## application.rb 

    [root@localhost jay]# vi /usr/local/lib/ruby/gems/1.9.1/gems/railties-3.2.3/lib/rails/commands/application.rb 
    
    require 'rails/version'
    
    # 判断第一个参数是否是 --version或-v
    # 如果是,直接输出rails版本
    if ['--version', '-v'].include?(ARGV.first)
      puts "Rails #{Rails::VERSION::STRING}"
      exit(0)
    end
    
    # 如果命令不是rails new把第一个参数设置为--help
    if ARGV.first != "new"
      ARGV[0] = "--help"
    else
    # rails new
      ARGV.shift
      railsrc = File.join(File.expand_path("~"), ".railsrc")
      if File.exist?(railsrc)
        extra_args_string = File.open(railsrc).read
        extra_args = extra_args_string.split(/\n+/).map {|l| l.split}.flatten
        puts "Using #{extra_args.join(" ")} from #{railsrc}"
        ARGV << extra_args
        ARGV.flatten!
      end
    end
    
    require 'rubygems' if ARGV.include?("--dev")
    require 'rails/generators'
    require 'rails/generators/rails/app/app_generator'
    
    module Rails
      module Generators
        class AppGenerator
          # We want to exit on failure to be kind to other libraries
          # This is only when accessing via CLI
          def self.exit_on_failure?
            true
          end
        end
      end
    end
    
    Rails::Generators::AppGenerator.start


## 参数

[rails3 初始化和启动](http://zires.info/2011/02/rails3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%90%AF%E5%8A%A8-initialization-process/)
